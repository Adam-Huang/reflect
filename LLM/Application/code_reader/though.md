
# 我的目的
希望设计一个代码阅读Agent，或者说是开源项目阅读Agent，目的是：
1. 快速找到、吸取其中优秀的设计思想
2. 借鉴整体设计架构的思想

# 我有什么？
download 到本地的开源代码库
还有一个通用的 action 基类，可以调用 LLM API 若干。

# 准备怎么做？
拿到一个工程，
* 先 tree 一下，了解其文件结构。
* 然后从最基础的文件开始，阅读每一个变量，每一个函数，整理其功能和含义，落对应的文档。
* 按照类似DFs 的原理，把每个函数读完了之后，总结整个文件的功能描述文件。
* 把一个文件夹内的文件读完后，总结整个文件夹的功能描述文件。继而整理整个工程的功能。

这个过程类似 GraphRAG 里的切片和构建图谱，因此后面可以直接用相应的RAG把这部分直接做成知识问答。

可能存在的问题：
1. 一般一个优秀的开源项目，他的 README 是要先看的，看完后，应该是能为后续的一些操作提供指导的。
2. 阅读函数时，以python 为例，会有全局变量，如何扩大上下文范围
3. 会有 import 包，要尝试调用相应的 描述文件，帮助理解这个函数的意义

## 具体落实
1.  要 tree 一下的话，应该是需要一个 sdk 或者 api 的，输入是本地的路径，返回是一个 tree 的结果，触发时间应该是分析功能启动的同时就执行的。应该封装成一个 Tool
   这个 tree 的结果应该会一直有用，让后续的调度LM 知道当前的位置。
2. 要想只提取和当前分析的函数相关的变量，比如环境变量呀、相应的导入包，最简单的方法就是遍历下之前所有的行，只把对应的行给 LM 可以帮助 LM 更加聚焦。但是这样可能会存在一个隐患，就是变量在一些比较隐秘的地方的修改不容易被发现。
   或者前期简单粗暴一点，直接将相关依赖函数、包全部丢给LM，但每次只让他针对其中一个函数去分析，LM 自己去选择选取相关依赖。肯定会比较 耗 token，效果也不太好。但是可以先这样，后面在想如何精简输入。
   此部分需要工具吗？需要。需要一个提取包函数，或者包文件的工具。

除此之外还差什么？

1. **README 文件的处理**
   - **优先级**：在开始分析代码之前，优先处理README文件。README通常包含了项目的概述、安装指南、使用说明、架构设计等信息，这些信息对于理解整个项目非常有帮助。
   - **工具**：可以设计一个工具，专门用于解析和提取README文件中的关键信息，如项目目标、架构设计、主要模块等。
   - TODO： README 里可以提取有用信息，但是感觉并不是每一层都用得到，可以用 RAG 的形式动态注入？还是怎么滴呢？

2. **全局变量的处理**
   - **上下文管理**：在分析函数时，确保全局变量和环境变量的上下文被正确传递。可以设计一个上下文管理器，用于存储和传递全局变量、环境变量等信息。
   - **动态追踪**：如果可能，可以考虑使用动态追踪工具（如Python的`sys.settrace`）来捕获全局变量的变化，确保在分析函数时能够获取到最新的全局状态。
   - 这个感觉高级了，初期可能不会考虑运行这个代码。

3. **依赖包的处理**
   - **依赖解析**：设计一个工具，用于解析和提取代码中的依赖包。这个工具可以解析`import`语句，并从本地或远程获取依赖包的描述文件（如`requirements.txt`或`setup.py`）。
   - **依赖图谱**：构建一个依赖图谱，展示各个模块之间的依赖关系。这可以帮助你更好地理解模块之间的交互和依赖关系。
   - 初期不考虑

4. **代码切片与图谱构建**
   - **切片工具**：设计一个工具，用于将代码切片成更小的单元（如函数、类、模块），并构建一个代码图谱。这个图谱可以用于后续的RAG（Retrieval-Augmented Generation）任务。
   - **图谱更新**：在分析过程中，动态更新代码图谱，确保图谱中的信息是最新的。
   - 哎，这个可以，需要考虑 类呀，继承呀，还有函数。可以先只考虑简单场景，后面再扩展。
   - 那么问题来了，这个是用LM还是函数呢？用LM吧，用函数就会要考虑各种case，没人力，用 LM怎么做呢？
     * 分析工程的 action 
       * 先看有没有对应的 文件夹、文件的总结文件，
         * 有则直接读取
         * 没有则，调用 分析文件夹 和 分析文件的 action，
       * 然后总结
     * 分析文件夹的 action 调用 分析文件的 action
     * 分析文件的action 需要一顿操作；
     1. 先切片
     2. 遍历每个切片
        1. 确认是否可以开始分析，还差点什么？需要一个【判断准入的 action】准入标准是所有的依赖都找到对应的含义了。
        2. 如果不可以分析，就等待。比如依赖(import 的包信息不知道，类里调用了其他方法而不了解其他方法的作用，或者是有调用基类)；
        3. 如可以分析，就进入分析流程
        4. 切片问题了，用 规则 还是 用 LM 切片呢？我的目的肯定是完整的切出 class 呀 def 呀之类的。
          1. ~~用 LM 吧，方便点。为了防止输出太多，输出就让他弄成 行号吧。需要一个【切片 action】，不需要看懂代码，只需要将文件内的代码生成 字典树即可，TBD：这个字典树如何设计呢？~~
          2. LM 太容易收到干扰了，还是 用 程序比较稳
        5. 确定了切片就可以分析了。

5. **LLM API 的优化**
   - **输入优化**：在将代码片段传递给LLM之前，进行预处理，去除不相关的代码行，只保留与当前分析函数相关的部分。这可以减少token的使用，提高分析效率。
   - **输出结构化**：设计一个结构化的输出格式，用于存储LLM的分析结果。这样可以方便后续的查询和检索。
   - 哎，这个有用，但是没想好咋实现。

6. **工具集成**
   - **工具链**：将上述工具集成到一个统一的工具链中，确保各个工具之间的数据能够无缝传递。可以使用一个调度器来管理工具的调用顺序和依赖关系。
   - **日志与监控**：设计一个日志系统，用于记录工具的执行过程和结果。同时，可以设计一个监控系统，用于监控工具的执行效率和结果质量。
   - 这个好

7. **用户交互**
   - **交互界面**：设计一个用户友好的交互界面，用于展示分析结果、代码图谱、依赖关系等信息。用户可以通过这个界面进行查询、导航和进一步分析。
   - **反馈机制**：设计一个反馈机制，允许用户对分析结果进行反馈，以便不断优化工具的性能和准确性。
   - 这个也好，咋实现呢？

8. **性能优化**
   - **并行处理**：考虑使用并行处理技术，加快代码分析的速度。可以将不同的模块或函数分配给不同的LLM实例进行并行处理。
   - **缓存机制**：设计一个缓存机制，用于存储已经分析过的代码片段和结果。这样可以避免重复分析，提高效率。
   - 初期不考虑效率问题

9. **测试与验证**
   - **测试用例**：设计一些测试用例，用于验证工具的正确性和鲁棒性。测试用例可以包括不同类型的代码库、不同复杂度的函数等。
   - **验证机制**：设计一个验证机制，用于验证LLM的分析结果是否准确。可以结合人工验证和自动化验证两种方式。

10. **扩展性**
   - **多语言支持**：考虑支持多种编程语言，而不仅仅是Python。可以设计一个通用的代码解析器，用于解析不同语言的代码结构。
   - **插件机制**：设计一个插件机制，允许用户自定义工具和功能。这样可以方便用户根据自己的需求扩展工具的功能。



## 切片问题
1. 程序切片
   1. 目前处理了 python 文件，包括段落（类、函数等）选取，因为我认为，要想很好的分析，完整代码片段 很重要，如果用 LM 万一切片不完整，怎么办。
   2. 只能处理 python 文件，其他文件，我还是得实现一套。
      1. 看看实现的这一套，是啥吧：
         1. 拿到一个工程， tree 一下肯定是必要的，LM 制定下分析顺序。输出一个 list 表明我的遍历顺序，肯定是先读 readme 了解大概，然后制定阅读计划
         2. 当要读的时候
            1. 第一 判断 要不要 读，以及要不要全部读？
               1. 代码、脚本、配置文件肯定读
               2. 数据文件就抽样读即可 -- 遇到 list 就抽样， 专注点
            2. 第二 读的依赖少不少
               1. 少：函数、变量、类，的声明不在 scope 之内，需要调用 - 输出一部分字段 比如 "need_reference": []
               2. 少：代码被切断（如果用）
                  1. 一种方法是继续往下取得所有代码后分析
                  2. 一种方法是先总结当前方法
               3. 不少：进行分析
               4. 不少：文本文件可以滚动总结合并
2. LM cover


**制定阅读计划**
```lua
# 目的
了解一个工程：1. 快速找到、吸取其中优秀的设计思想；2. 借鉴整体设计架构的思想

## 当前任务
从项目大纲和README 文件开始，**制定阅读计划**，包括阅读顺序、以及需要阅读的文件

# 已知
1. 项目二级大纲，来自 `os.walk`  -- 这个回头LM生成一下
{{tree}}
2. README 文件摘要 -- 读文件的工作交由具体任务执行，这里只放摘要
{{file_content}}

# 要求
## 输出
1. 输出一个 list，每个元素是一个 dict，包含以下字段：
   * `file_path`
   * `priority` -- 优先级，数字越大优先级越高，最高为 10
## 注意
```

**读一个文件**
```lua
# 目的
了解一个工程：1. 快速找到、吸取其中优秀的设计思想；2. 借鉴整体设计架构的思想

## 当前任务
阅读当前文件片段，分析每一步的含义，并总结当前片段含义

# 已知
1. 当前文件的 URI
{{file_path}}
2. 当前文件的片段
{{file_content}}

# 要求
## 输出
1. 输出一个  dict，包含以下字段：
   * `StepByStep`: str -- 每一步的含义
   * `Summary`: str -- 当前文件内容的总结
   * `Labels`: List[str] -- 当前文件内容的标签，是一个 list，每个元素是一个标签
## 注意
```

肯定还存在问题，后续首先 跑通一个文件 就 Meta GPT 吧

